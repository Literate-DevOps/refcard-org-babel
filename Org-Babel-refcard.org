#+TITLE:     Org Babel quick reference card
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+Time-stamp: <2014-02-26 Wed 22:52>
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:nil

#+SETUPFILE: ~/src/org-style/setup/bigblow-pirilampo.setup

#+PROPERTY: eval no

* Org Babel reference card

Welcome to Org Babel reference card. It contains the reference documentation
that describes how to perform *code execution* within Org documents using Org
Babel 8.

* Compendium principles

** Literate Programming

*Literate programming* offers 2 classical operations:

- Tangle ::
     Extract the source code blocks and generate *real working code* files for
     further compilation or execution, eventually outside of Emacs.

- Weave ::
     Export the whole Org file as literate, *human-readable documentation*
     (generally in HTML or LaTeX).

** Reproducible Research

Above those, Org Babel adds /in situ/ code evaluation:

- during *interactive* use,
- during *tangle*, and/or
- during *export* (code blocks with =:exports= set to =results= or =both=)

This allows you to insert in your Org document:

- all *data* (that can reasonably be included),
- all *code* you used, and
- the full set of *outputs* you got,

following the principles of *reproducible research*.

* Evaluation

** Code blocks

A *code block* is some sort of subprogram which does the desired job.

*** Defining a code block

You can *define* and *call* it at the same time: the code block definition itself
acts as an *implicit call*.

**** Syntax

The code block is a block element which can be *anonymous* or *named*.

#+begin_src org
,#+begin_src <LANGUAGE> <HEADER-ARGS>
<BODY>
,#+end_src
#+end_src

Anonymous code blocks will be immediately followed by the results block.

#+begin_src sh :exports both
printf "I'm anonymous"
#+end_src

#+results:
: I'm anonymous

Named source code blocks will refresh the corresponding named *results blocks
anywhere* in the file.

#+name: example
#+begin_src sh :results output :exports both
printf "As I'm named, my results may live anywhere in the file."
#+end_src

It doesn't matter whether the code block and the results block are
"disconnected", such as here, as the results is a *named data* which Babel can
locate.

#+results: example
: As I'm named, my results may live anywhere in the file.

The name can be 20 characters long, and contain...XXX

**** Code block arguments

You can create a code block with optional parameters by specifying a *default
value* for optional parameters. When the code block is executed, the default
value is used if no other value has been specified in the call.

The way to define arguments is to declare them on the =#+begin_src= line.

#+name: square
#+begin_src emacs-lisp :var x=1
(* x x)
#+end_src

Specifying default values is necessary because each variable must be
initialized when the code block is executed.

If the variable semantics vary by language (as they do), just say so (e.g.
when defining a SQL function, vars are substituted into the body by prefixing
the names with $, but in python they are local vars in non-session mode and
global vars in session mode and so on. Maybe this doc section shouldn't try to
enumerate all those languages, but just redirect to the proper Worg Babel
language page for details on arg handling.

Pass by value.

***** Keyword arguments

***** Default arguments

**** Scope of Variables

***** Global variables

***** Local variables

**** Examples

***** Using :headers

Code can (possibly) be easier to read/write when splitting header arguments
among multiple lines, by writing the options above the code block.

#+header: :file test.png :fit yes
#+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 400
#+header: :results (if (and (boundp 'backend) (eq backend 'latex)) "latex" "file")
#+begin_src latex :exports results :noweb yes :headers '("\\usepackage{tikz}")
  \begin{tikzpicture}
    \node[red!50!black] (a) {A};
    \node (b) [right of=a] {B};
    \draw[->] (a) -- (b);
  \end{tikzpicture}
#+end_src

***** Do stuff conditional to the export backend

Maybe you could do something like the following...

#+name: export-hdr-arg-backend-dep
#+begin_src emacs-lisp
(message "do stuff")
#+end_src

# #+call: export-hdr-arg-backend-dep() :exports (if (eq org-export-current-backend 'beamer) "none" "results")

***** Cross-referencing a results block

>> #+results are never used for cross-references. This is a Babel internal
>> keyword used to refer to the source that generated this element.
>>
>> Cross-references only react to #+name keyword.
>
> Sorry, this is confusing. Is it then the case that we are naming the
> source block to ensure that captions stick to the corresponding
> results block?

Source block captions apply to the source block, not to the results. You
have to define a separate caption for the results.

Source block name will be used both as a label for cross referencing and
as a Babel internal code for results correspondence.

> And then, we need to separately name the results block, and use
> a different name for it, so that the cross-references pick it up
> correctly?

Yes, the name given to the results block doesn't depend on the results
keyword. You can give it any name, as long as it is unique.

Here is an example:

  #+caption: Src block caption
  #+name: my-src
  #+begin_src emacs-lisp
  (+ 1 2)
  #+end_src
  #+name: anything
  #+caption: Element caption
  #+results: my-src
  : 3

***** Other explanation

You need to apply =CAPTION= and =NAME= keywords on the results, not the source
code.

*** Calling a code block

You can *define* a code block somewhere and then *call* it *explicitly* elsewhere
--- provided the code block has a =#+name:= meta data to label it.

**** Syntax

=#+call:= is for *standalone lines*: it lives on a block by itself.

A =#+call:= line can be *named*, in order for its *results* (for the arguments used)
to be *referenced*.

It has the following syntax, where each header argument portion is optional.

#+begin_src org
,#+name: <CALL-LINE-NAME>
,#+call: <NAME>[<HEADER-ARGS-FOR-BLOCK>](<ARGUMENTS>) <HEADER-ARGS-FOR-CALL-LINE>
#+end_src

- NAME ::
     Name of the code block to be evaluated.

- ARGUMENTS ::
     XXX Describe how to pass args.

- HEADER-ARGS-FOR-BLOCK ::
     Header arguments applied to the *evaluation of the code block*. They affect
     how the code block is evaluated: they *change the inputs*.

     For example, =:session *org-R*= or =:results output=.

- HEADER-ARGS-FOR-CALL-LINE ::
     Header arguments applied to the *evaluation of the #+CALL: line*. They do
     not affect evaluation of the named code block.

     For example, =:exports results= or =:results html=.

**** Remarks

=#+call:= lines recently got =#+names=, hopefully soon they will get =#+header=
arguments as well.

When *evaluating a call line*, it is converted into an ephemeral Emacs Lisp code
block equivalent to the call line (and created at the point of the call line):

#+begin_src org
,#+begin_src emacs-lisp :var result=<NAME>(<ARGUMENTS>) <HEADER-ARGS-FOR-BLOCK>
,  result
,#+end_src
#+end_src

which is evaluated in place.

The result of the called function is passed into this ephemeral block, and the
output of the block is inserted into the buffer.

This is why call lines have *two* possible sets of header arguments:
- one to pass header arguments to the original code block being called, and
- one for local effect in the ephemeral block.

    Advice (from Rick Frankel):
    As to the "call" lines, think of the output of the "called" block as being
    input to an anonymous block (the #+call), so the hlines are stripped.

Press =C-c C-v C-e= on the call line to *execute* the block.

Code blocks are sometimes located in a separate file (called "library of
Babel") which can be included in other Org files that wish to use the code
blocks.

**** Examples

***** Relying on the default value of the arguments

***** Providing explicit values to the arguments

#+begin_src org
,#+call: foo(bar=1)
#+end_src

is equivalent to

#+begin_src org
,#+begin_src emacs-lisp :var results=foo(bar=1)
,  results
,#+end_src
#+end_src

***** Recursive

#+name: add1
#+begin_src emacs-lisp :var x=1 :results silent
  (+ x 1)
#+end_src

#+CALL: add1(x=4)

#+results: add1(x=4)
: 5

#+CALL: add1(6)

#+results: add1(6)
: 7

#+call: add1(add1(9))

#+results: add1(add1(9))
: 11

***** Other

It is possible to pass the =:dir= header argument through a call line.

#+name: where
#+begin_src sh
  pwd
#+end_src

#+RESULTS: where
: /tmp

Call the above from somewhere else.

#+call: where[:dir /]()

#+RESULTS:
: /

***** Call by name

Let's assume, the original code block takes an argument.

#+name: echo-string
#+begin_src sh :var input="original"
  echo "input=$input"
#+end_src

#+RESULTS: echo-string
: input=original

If I want to "get rid of" that argument (to avoid typing), I can to name the
result of calling that code block with a specific argument.

#+name: echo-new
#+call: echo-string("new")

#+RESULTS: echo-new
: input=new

As =#+call:= lines can be named, it is possible to reference that result.

#+begin_src sh :var input=echo-new()
  echo "this=$input"
#+end_src

#+RESULTS:
: this=input=new

*** Calling a code block from other elements

Using the =org-sbe= (for "source block evaluate") macro, you may call arbitrary
code blocks

- in a *table formula*,
- in *file local variables*,
- inside of an *elisp link*, or
- in any *[[id:e9f52887-3230-4b26-98a2-97169036b1d0][header argument]]*.

**** Syntax

Return the results of calling =NAME= with =VARIABLES=.

#+begin_src org
(org-sbe '<NAME> <VARIABLES>)
#+end_src

Each element of =VARIABLES= should be a two element list, whose

- first element is the name of the variable and
- second element is a *string* of its value.

By default, string variable names are interpreted as references to source-code
blocks. To force interpretation of a cell's value as a string, prefix the
identifier with a =$= (e.g., =$$2= instead of =$2= or =$@2$2= instead of =@2$2=).

In order to differentiate between strings and reference names, we surround all
strings in double quotes...

From [[http://osdir.com/ml/emacs-orgmode-gnu/2010-03/msg00651.html][Re: {Orgmode} {babel} passing strings in - msg#00651 - emacs-orgmode-gnu]]

... or double the $ sign: $$1

#+name: leftover
#+begin_src emacs-lisp :var prefix=""
 (-
  ;; length w/o .el
  (- 13 (length ".el"))
  ;; length of prefix
  (length prefix))
#+end_src

| prefix   | remaining characters |
|----------+----------------------|
| ob-      |                  nil |
| org-b-   |                  nil |
| orgb-    |                  nil |
| org-bbl- |                  nil |
| bbl-     |                  nil |
| babel-   |                  nil |
#+TBLFM: $2='(org-sbe leftover (prefix $$1))

**** Remarks

#+begin_src org
(org-sbe 'NAME (n $2) (m 3))
#+end_src

The preceding call to =org-sbe= is equivalent to the following source code block.

#+begin_src org
,#+begin_src emacs-lisp :var results=NAME(n=val_at_col_2, m=3) :results silent
results
,#+end_src
#+end_src

There is no way to *map* a *code block* over the *rows of a table*. You could use
the =org-sbe= macro and a spreadsheet formula to call a code block on multiple table
cells, but the results would be inserted back into the table.

| A       |           nil |
| B       |           nil |
| eric    |           nil |
| schulte |           nil |
#+TBLFM: $2='(org-sbe foo (in $$1))

#+name: foo
#+begin_src emacs-lisp :var in="foo"
(format "-->%s<--" in)
#+end_src

Also remember you can use ELisp in formulas:

| Date 1                  | Date 2                  | Duration |
|-------------------------+-------------------------+----------|
| [2013-12-21 sam. 00:00] | [2013-12-22 dim. 00:00] | 86400.0  |
#+TBLFM: $3='(- (org-time-string-to-seconds "$2") (org-time-string-to-seconds "$1"));L

Note the quotes around "$2" and "$1", they are necessary so that the date is
not literally inserted in the formulas when Org is computing it.

***** Test looping over a table: "noweb" call blocks

http://lists.gnu.org/archive/html/emacs-orgmode/2010-11/msg01014.html

#+tblname: accounts
| EBAY | Expenses:Advertising         |
| Q8   | Expenses:Auto:Fuel           |
| VISA | Liabilities:Credit-Card:Visa |

#+name: account-rules-python
#+begin_src python :var data=accounts :exports code :results output :tangle no
for line in data:
    print "---"
    print "- 'm/" + line[0] + "/'"
    print "- ''"
    print "- '" + line[1] + "'"
#+end_src

#+begin_src yaml :tangle AccountMatches.yaml :noweb yes
# This is the file header...

<<account-rules-python()>>
#+end_src

**** Examples

***** Calling a code block in a table formula, relying on the default value of the arguments

#+TBLFM: $2='(org-sbe "totals")

#+TBLFM: $2='(org-sbe "totals" (details "expenses[1:-1])"))

***** Calling a code block in a table formula, providing explicit values to the arguments

#+name: mean
#+begin_src emacs-lisp :var l=()
  (let ((num (car l))
        (nums (cdr l)))
    (/ (float (+ num (apply #'+ nums)))
       (1+ (length nums))))
#+end_src

| x | y | z | mean |
|---+---+---+------|
| 2 | 3 | 5 | 0.00 |
#+TBLFM: @2$4='(org-sbe mean (l $1..$3));%.2f

***** Passing header arguments

It is also possible to pass header arguments to the code block. In this case,
a table cell should hold the string value of the header argument which can
then be passed before all variables.

#+name: test-org-sbe
#+begin_src emacs-lisp :var x=0 :var y=0
(+ x y)
#+end_src

| 1 | 2 | :file nothing.png | nil |
#+TBLFM: @1$4='(org-sbe test-org-sbe $3 (x $1) (y $2))

***** Using =org-sbe= in a local variables line

You can run some preparatory code (in any language) when the file is opened for
the first time by using =(org-sbe NAME)= (where =NAME= is a double-quoted string)
in *Local Variables* lines, at the end of the Org file.

#+begin_src org
,#+name: init
,#+begin_src R :session *R*
# initialize some stuff
,#+end_src

# Local variables:
# eval: (org-sbe "init")
# End:
#+end_src

Emacs will evaluate the set-up block(s), after asking for confirmation.

***** Using =org-sbe= inside of an elisp link

#+name: counter
#+begin_src sh :results output :var to=6
for i in $(seq 1 $to); do
   printf $i;
done
#+end_src

#+results: counter
: 123456

Clicking on the following hyperlink will execute the code block.

#+begin_src org
[[elisp:(org-sbe counter (to "3"))][count to 3]]
#+end_src

***** Using =org-sbe= to assign header arguments

You can use arbitrary Lisp forms to assign header arguments. For example, to
dynamically *compute the file name*.

The following generates a file which is conditional to the export target:

- a =.pdf= image for LaTeX export and
- a =.png= image for HTML export.

#+name: get-file-path
#+begin_src emacs-lisp
(if (and (boundp 'latexp) latexp)
    "Rplots.pdf"
  "Rplots.png")
#+end_src

#+begin_src R :file (org-sbe "get-file-path")
x <- seq(-pi, pi, by=0.05)
plot(x, sin(x))
#+end_src

#+results:
[[file:Rplots.png]]

#+name: current-revision
: rev-3.14

#+header: :file (concat "Rplot_" (org-sbe current-revision) ".png")
#+begin_src R :eval yes
x <- seq(-pi, pi, by=0.05)
plot(x, sin(x))
#+end_src

#+results:
[[file:Rplot_rev-3.14.png]]

The following works great. (note the tick in the =(boundp 'backend)=).

# #+call: disc[:file (if (and (boundp 'backend) (equal backend 'html)) "fox.svg" "fox.pdf")]() :results file

And you could wrap up the extra-long Emacs Lisp in a function or macro in your
init to avoid the overlength header argument.

** Inline code blocks

An *inline source block* is a code block which is contained in a paragraph of
text. It was added so that *results* of code blocks could be *exported* inline in
blocks of prose.

*** Syntax

The basic syntax structure for inline code blocks is:

#+begin_src org
src_<LANGUAGE>{<BODY>}
#+end_src

without header arguments, and:

#+begin_src org
src_<LANGUAGE>[<HEADER-ARGS>]{<BODY>}
#+end_src

with header arguments.

*** Remarks

- *Inline code blocks don't associate themselves with their results*, they are
  *only expected to be evaluated during export*. They are not intended to be
  executed in the buffer during normal use.

- Inline code blocks are treated just like code blocks, however they have
  different default header arguments: see
  =org-babel-default-inline-header-args=.

- If you set the following

  #+begin_src emacs-lisp
  (setq org-babel-inline-result-wrap "$%s$")
  #+end_src

  then inline code snippets will be wrapped into the formatting string.

*** Examples

This file was exported on
src_emacs-lisp{(format-time-string "%Y-%02m-%02d %3a %02H:%02M")}.

The answer to 2 + 3 is src_emacs-lisp{(+ 2 3)}.

One plus one equals src_R{1 + 1}.

Two plus two equals src_lisp{(+ 2 2)}.

A definition returns "src_lisp[]{(defun x (y) (* y y))} ".

src_python[:session]{10*x}, where x is a variable existing in the python
session.

** Inline Babel calls

*** Syntax

The syntax for inline evaluation of named code blocks is the following, where
each header argument portion is optional.

#+begin_src org
... call_<NAME>[<HEADER-ARGS-FOR-BLOCK>](<ARGUMENTS>)[<HEADER-ARGS-FOR-CALL-LINE>] ...
#+end_src

*** Remarks

*** Examples

Simple examples for inline call:

#+name: square
#+begin_src emacs-lisp :var x=0
(* x x)
#+end_src

I should be able to put the output inline using call_square(x=4).

Here is a call_square(x=4), stuck in the middle of some prose.

The following exports as a normal call line:

#+call: square(x=1)

Now here is an inline call call_square(x=1) stuck in the middle of some prose.

This one should not be exported =call_square(x=2)= because it is quoted.

Finally this next one should export, even though it starts a line
call_square(x=3) because sometimes inline blocks fold with a paragraph.

And, a call with raw results call_square(4)[:results raw] should not have
quoted results.

call_foo(bar=(+ 2 2))

* Header arguments
  :PROPERTIES:
  :ID:       e9f52887-3230-4b26-98a2-97169036b1d0
  :END:

** Standard header arguments

The following table lists the standard header arguments that Org Babel uses.

# org-babel-common-header-args-w-values
# http://orgmode.org/manual/Specific-header-arguments.html#Specific-header-arguments

| [[#cache][:cache]]     | [[#noweb-ref][:noweb-ref]]   |
| [[#cmdline][:cmdline]]   | [[#noweb-sep][:noweb-sep]]   |
| [[#colnames][:colnames]]  | [[#padline][:padline]]     |
| [[#comments][:comments]]  | [[#post][:post]]        |
| [[#dir][:dir]]       | [[#prologue][:prologue]]    |
| [[#epilogue][:epilogue]]  | [[#results][:results]]     |
| [[#eval][:eval]]      | [[#rownames][:rownames]]    |
| [[#exports][:exports]]   | [[#sep][:sep]]         |
| [[#file][:file]]      | [[#session][:session]]     |
| [[#file-desc][:file-desc]] | [[#shebang][:shebang]]     |
| [[#hlines][:hlines]]    | [[#tangle][:tangle]]      |
| [[#mkdirp][:mkdirp]]    | [[#tangle-mode][:tangle-mode]] |
| [[#no-expand][:no-expand]] | [[#var][:var]]         |
| [[#noweb][:noweb]]     | [[#wrap][:wrap]]        |

** Extra language-specific header arguments

The following table lists the header arguments that some languages use.

| :border        | :java             |
| :buffer        | :main             |
| :classname     | :nullvalue        |
| :cmd           | :out-file         |
| :cmd-line      | :package          |
| :cmpflag       | :packages         |
| :colname-names | :pdf              |
| :database      | :pdfheight        |
| :db            | :pdfpng           |
| :dbhost        | :pdfwidth         |
| :dbpassword    | :preamble         |
| :dbuser        | :result-params    |
| :defines       | :result-type      |
| :engine        | :results_switches |
| :eps           | :return           |
| :filetype      | :rowname-names    |
| :fit           | :scheme           |
| :flags         | :separator        |
| :headers       | *:stdin*            |
| :imagemagick   | :tangle           |
| :iminoptions   | :term             |
| :imoutoptions  | :terminal         |
| :in-file       | :xmp-option       |
| *:includes*      |                   |

*** :preamble

Specifies code block prefix for code evaluation.

*** :separator

Specifies a different results separator.

** Inheritance

Header arguments can be set at different levels of a hierarchy:

1. [[id:7b0711cf-353b-4382-bc19-093e4e67ca92][*Default* header arguments]] shipped with Org mode
2. [[id:1cadb447-8403-400c-9117-13db017cc198][Default *languages-specific* header arguments]] shipped with Org mode
3. [[id:aebeec14-5693-4c38-8040-c91d28ade608][*Buffer* (or file) level header arguments]]
4. [[id:e7fda871-60ec-47d5-aee0-130c7d06fab2][*Subtree* header arguments]]
5. [[id:69939aec-bdee-449b-87fd-420daa53eaba][*Code block* header arguments]]
6. [[id:3fe40664-b445-4ae4-8248-8847576732fa][*Call line* header arguments]]

At the top of the hierarchy, default header arguments shipped with Org mode
are the most general of all: they define behavior common to all code blocks,
unless set otherwise, inherited by all lower levels.

Header arguments near the bottom of the hierarchy provide behavior more
specific to a (group of) code block(s).

*** Default header arguments shipped with Org mode
    :PROPERTIES:
    :ID:       7b0711cf-353b-4382-bc19-093e4e67ca92
    :END:

- Variable =org-babel-default-header-args= for source blocks
- Variable =org-babel-default-inline-header-args= for inline source blocks
- Variable =org-babel-default-lob-header-args= for =#+call= lines

These default header arguments can be set by the user:

#+begin_src emacs-lisp
;; add default arguments to use when evaluating a source block
(add-to-list 'org-babel-default-header-args
'(:noweb . "yes"))
#+end_src

This can also be done file-wide through the use of /file local variables/.

*** Default languages-specific header arguments shipped with Org mode
    :PROPERTIES:
    :ID:       1cadb447-8403-400c-9117-13db017cc198
    :END:

- Variable =org-babel-default-header-args:emacs-lisp= for Emacs Lisp
- Variable =org-babel-default-header-args:R= for R
- Variable =org-babel-default-header-args:org= for Org
- Etc.

Header arguments which have different defaults between languages:

| Languages                      | :exports | :hlines | :results       |
|--------------------------------+----------+---------+----------------|
| general-purpose languages + /sh/ | code     | no      | replace        |
| /ledger/                         | code     | no      | output replace |
| /org/                            | code     | no      | silent raw     |
| /latex/                          | results  | no      | latex replace  |
| graphics-only languages        | results  | no      | file replace   |

These default language-specific header arguments can be changed by the user:

#+begin_src emacs-lisp
(add-to-list 'org-babel-default-header-args:R
             '(:session . "*org-R*"))

(add-to-list 'org-babel-default-header-args:R
             '((:width . 640) (:height . 640)))
#+end_src

This can also be done file-wide (for certain files) through the use of:
- [[id:aebeec14-5693-4c38-8040-c91d28ade608][property lines]] or
- /file local variables/.

*** Buffer (or file) level header arguments
    :PROPERTIES:
    :ID:       aebeec14-5693-4c38-8040-c91d28ade608
    :END:

A =#+PROPERTY:= line located *anywhere* in a buffer affects the entire file: it
sets a *global* property.

For example, when you want to tangle all source blocks in an Org file, include
the line:

: #+PROPERTY: tangle yes

That can be over-ridden on a [[id:e7fda871-60ec-47d5-aee0-130c7d06fab2][per-subtree]] or [[id:69939aec-bdee-449b-87fd-420daa53eaba][per-block]] basis.

Since *only one property may be specified per property line*, there is *no need
for colons*.

Multiple lines may be used to specify multiple properties:

: #+PROPERTY: results output code append
: #+PROPERTY: cache yes
: #+PROPERTY: tangle force-the-output-to-that-file.el

In the case of two =#+PROPERTY:= lines for the same property, the property will
have the later value.

The property mechanism is a general mechanism for the concatenation of property
strings. Any property specification unless it is postfixed with a =+= will /reset/
the value of that property to its current value.

*** Subtree header arguments
    :PROPERTIES:
    :ID:       e7fda871-60ec-47d5-aee0-130c7d06fab2
    :END:

In contrast to property lines, a =:PROPERTIES:= block is only valid for the given
tree (and subtrees).

*** Code block header arguments
    :PROPERTIES:
    :ID:       69939aec-bdee-449b-87fd-420daa53eaba
    :END:

*** Call line header arguments
    :PROPERTIES:
    :ID:       3fe40664-b445-4ae4-8248-8847576732fa
    :END:

** :cache
   :PROPERTIES:
   :CUSTOM_ID: cache
   :END:

Avoids re-evaluating unchanged code blocks.

*** Options

- =:cache no= ::
     (default)

- =:cache yes= ::
     Avoids re-evaluating unchanged code blocks by associating a *hash* of the
     /expanded/ code block (= code block and parameters) with the *results*. It
     allows the results to be returned without having to re-run the code block
     --- unless the code or the input parameters have changed.

*** Remarks

In order for caching to work (i.e., *no evaluation* when triggered either
*interactively* or *during export*), the results of the code block must be present
in the Org mode file: you must first evaluate it manually, leaving the results
(with the hash tag) saved within the Org mode file.

Note that same input does *not* always *guarantee the same output*, e.g.,

#+begin_src sh
date
#+end_src

Though, this code block shouldn't be marked =:cache= unless the desired (and
odd) behavior is to have a datestamp that is only updated when the user
forcibly re-evaluates the block (with =C-u C-c C-v C-e=).

*** Examples

**** Avoid re-evaluating unchanged code blocks

The following example uses the cache optimization for a very long running code
block.

#+begin_src org
,#+begin_src sh :eval yes :results verbatim :cache yes
printf "Please wait (this can take a while)...\n"
sleep 5
printf "Done!\n"
,#+end_src
#+end_src

Here is the results block, evaluated within no time, except for the very first
time it is run.

#+begin_src org
,#+results[af6f...]:
,#+begin_example
Please wait (this can take a while)...
Done!
,#+end_example
#+end_src

**** Avoid re-evaluating code blocks unless some process restarts

The following example allows to include the PID of the R process in the results
hash, so that the code would be rerun only if the R process (session) restarts.

#+name: R-pid
#+begin_src sh :var R="/usr/lib64/R/bin/exec/R"
ps -a | grep "$R" | grep -v 'grep' | awk '{print $2}'
#+end_src

#+begin_src R :var pid=R-pid :cache yes
# code to perform side effect
x <- 'side effect'
'done' # add something small to get a results block
#+end_src

#+results[609468f06f835a6ce8591f76f48c95fc2e2d9823]:
: done

*** See also

**** Reference

[[#eval][:eval]] \\
[[#exports][:exports]]

** :cmdline
   :PROPERTIES:
   :CUSTOM_ID: cmdline
   :END:

*** Options

- none ::
     (default)

- =:cmdline ...= ::

*** Remarks

The =:cmdline= header argument is supported by a couple of languages.

*** Examples

For shell, this allows to make the code inside a Babel code block similar to
a real shell script.

#+begin_src sh :cmdline "foo bar baz"
echo $2
#+end_src

#+results:
: bar

The script can use =$@= for its positional parameters.

#+begin_src sh :cmdline "foo bar baz"
echo "$@"
#+end_src

#+results:
: foo bar baz

Also, calling the script using =#+call= is like calling it from another shell
script (supplying the value in the call line).

** :colnames
   :PROPERTIES:
   :CUSTOM_ID: colnames
   :END:

Handles *column names in tables*.

*** Options

- none ::
     (default) Removes the header (and the top hline) from the table before
     processing if the input table looks like it has column names (because its
     second row is an hline).

- =:colnames no= ::
     (default for Emacs Lisp code blocks)
     Don't strip the header. Re-add headers (post-processing).

- =:colnames yes= ::
     Tells Org Babel that your first row contains column names. Applies the
     code block to the body of the input table.

- =:colnames <LIST>= ::
     Specifies to use =<LIST>= as column names.

- =:colnames '()= ::
     *Unsets* the header argument if set at a higher level. Is the same as
     "none" WHEN NOT SET AT A HIGHER LEVEL.

*** Remarks

By default, the first row will be used for column names if followed by a =hline=
XXX???XXX. Without a =hline=, use =:colnames yes=.

#+name: colrownamestbl
|        | Alpha | Beta | Gamma |
|--------+-------+------+-------|
| First  | A1    | B1   | C1    |
| Second | A2    | B2   | C2    |
| Third  | A3    | B3   | C3    |

#+begin_src R :var data=colrownamestbl :rownames yes :results output
colnames(data)
rownames(data)
#+end_src

#+RESULTS:
: [1] "Alpha" "Beta"  "Gamma"
: [1] "First"  "Second" "Third"

*** Examples

Consider the following input tables, one without column names, one with column
names.

#+name: without-header
| 1 | one   |
| 2 | two   |
| 3 | three |

#+name: with-a-header
| num | word  |
|-----+-------|
|   1 | one   |
|   2 | two   |
|   3 | three |

**** Using no =:colnames= header argument

The following example outputs the table without column names.

#+begin_src R :var data=without-header :exports results :eval yes
data
#+end_src

#+results:
| 1 | one   |
| 2 | two   |
| 3 | three |

#+begin_src R :var data=with-a-header :exports results :eval yes
data
#+end_src

#+results:
| 1 | one   |
| 2 | two   |
| 3 | three |

**** Using =:colnames no=

The following example outputs all the rows of the table, considering there is
no column names.

#+begin_src R :var data=without-header :exports results :colnames no :eval yes
data
#+end_src

#+results:
| 1 | one   |
| 2 | two   |
| 3 | three |

#+begin_src R :var data=with-a-header :exports results :colnames no :eval yes
data
#+end_src

#+results:
| num | word  |
|   1 | one   |
|   2 | two   |
|   3 | three |

**** Using =:colnames yes=

The following example outputs the table with its column names.

#+begin_src R :var data=without-header :exports results :colnames yes :eval yes
data
#+end_src

#+results:
| X1 | one   |
|----+-------|
|  2 | two   |
|  3 | three |

#+begin_src sh :var data=without-header :colnames yes :eval yes
echo "$data"
#+end_src

#+results:
| 1 | one   |
|---+-------|
| 2 | two   |
| 3 | three |

#+begin_src R :var data=with-a-header :exports results :colnames yes :eval yes
data
#+end_src

#+results:
| num | word  |
|-----+-------|
|   1 | one   |
|   2 | two   |
|   3 | three |

#+begin_src emacs-lisp :var data=with-a-header :exports results :colnames yes :results scalar :eval yes
data
#+end_src

#+results:
: ((1 "one") (2 "two") (3 "three"))

**** Using specified column names

*XXX Will work with (unapplied) patch of Eric, on [2013-04-08 Mon]*

#+begin_src R :var data=without-header :exports results :colnames '(Rev Author)
data
#+end_src

#+results:
| X0 | foo |
|----+-----|
|  1 | bar |
|  2 | baz |

#+begin_src R :var data=with-a-header :exports results :colnames '(Rev Author)
data
#+end_src

#+results:
| id | var1 |
|----+------|
|  1 | bar  |
|  2 | baz  |

**** Show the labels of the vertical and the horizontal axes

#+BEGIN_SRC R :exports results :results output raw
org.files <- c (1, 0, 2, 2, 2, 2, 1)
happiness <- c (1, 0, 2, 2, 2, 1, 2)
data <- data.frame (org.files, happiness)
library (ascii)
print (ascii (table (data)), type = "org")
#+END_SRC

#+RESULTS:
|           |   | *happiness* |      |      |
|           |   |         0 |    1 |    2 |
|-----------+---+-----------+------+------|
| *org.files* | 0 |      1.00 | 0.00 | 0.00 |
|           | 1 |      0.00 | 1.00 | 1.00 |
|           | 2 |      0.00 | 1.00 | 3.00 |

**** Utility function

#+name: col-with-a-header
| numbers |
|---------|
| one     |
| two     |
| three   |
| four    |

#+begin_src emacs-lisp :var in=col-with-a-header :eval yes
(mapcar (lambda (row) (mapcar #'length row)) in)
#+end_src

#+results:
| 3 |
| 3 |
| 5 |
| 4 |

*** See also

**** Reference

[[#hlines][:hlines]] \\
[[#rownames][:rownames]]

** :comments
   :PROPERTIES:
   :CUSTOM_ID: comments
   :END:

Controls the insertion of extra comments into the tangled code files to allow
backward linking from tangled code blocks to the original code blocks (from
which the code was tangled).

*** Options

- =:comments no= ::
     (default)
     Does not insert any comments in tangled files (beyond those which may
     already exist in the body of the code block).

- =:comments link= ::
     Inserts "tangled from X" comments around the code blocks in the tangled
     file (with *links* back to the original Org mode file).

- =:comments noweb= ::
     Inserts comment wrappers (with *links* back to the original Org mode file)
     around all *embedded noweb* sections. Is an enhanced version of =:comments
     link=, that can break newlines in =<<block>> + 1=, for example. XXX

- =:comments org= ::
     Includes *preceding text* from the Org mode file as a comment before the
     code block (but does not wrap the code with links back to the original
     Org file).

- =:comments both= ::
     Turns on both the =link= and =org= comment options.

- =:comments yes= ::
     (deprecated)
     Is the same as =:comments link=.

*** See also

**** Reference

[[#tangle][:tangle]]

**** Other resources

The variable =org-babel-tangle-use-relative-file-links= controls whether files
and links in comments in tangled files use relative or absolute path names (it
defaults to relative paths).

** :dir
   :PROPERTIES:
   :CUSTOM_ID: dir
   :END:

Specifies the default (possibly *remote*) directory during code block execution.

*** Options

- none ::
     Uses the directory associated with the *current buffer*.

- =:dir <DIR>= ::
     Specifies to use =DIR= as the *default directory* for code block execution.

*** Remarks

You can use the =:dir= header argument for *remote execution*. The directory is
specified using using [[http://www.gnu.org/software/emacs/manual/html_node/tramp/Filename-Syntax.html][Tramp filename syntax]].

=:results output= seems to be necessary!

*** Examples

WHY DON'T WE HAVE TO SPECIFY :OUTPUT FOR THE SH BLOCK?

#+begin_src sh :dir /ssh:tortilla:/tmp
hostname
#+end_src

#+results:
: tortilla

#+begin_src python :dir /ssh:tortilla:/tmp :results output
import socket

print socket.gethostname()
#+end_src

#+results:
: tortilla

#+begin_src sh :dir /ssh:username@domain.org:
ls -la
#+end_src

#+begin_src sql :engine postgresql :dir /grid: :results output :colnames yes
SELECT 2+2 AS 'four', 1+1 AS 'one';
#+end_src

*** See also

**** Reference

[[#file][:file]]

** :epilogue
   :PROPERTIES:
   :CUSTOM_ID: epilogue
   :END:

Appends text to code block body.

*** Options

- =:epilogue ""= ::
     (default)

- =:epilogue <TEXT>= ::
     Appends the value of the =:epilogue= header argument to the code block
     body before execution.

*** See also

**** Reference

[[#prologue][:prologue]]

** :eval
   :PROPERTIES:
   :CUSTOM_ID: eval
   :END:

Specifies permissions for /every/ execution of code blocks.

*** Options

- =:eval yes= ::
     (default)
     Allows evaluation of the code block (both interactively and during
     export) WITHOUT A CONFIRMATION FROM THE USER?.

- =:eval query= ::
     Requires confirmation before evaluating the code block (both
     interactively and during export), regardless of the value of the
     =org-confirm-babel-evaluate= variable.

- =:eval query-export= ::
     Allows interactive evaluation of the code block, but requires
     confirmation before evaluating it during export, regardless of the value
     of the =org-confirm-babel-evaluate= variable.

- =:eval never= ::
     Inhibits (silently) evaluation of the code block (both interactively and
     during export). This is useful for protecting against the evaluation of
     dangerous code blocks.

- =:eval never-export= ::
     Allows interactive evaluation of the code block, but inhibits its
     evaluation during export.

- =:eval no= ::
     Is the same as =:eval never=.

- =:eval no-export= ::
     Is the same as =:eval never-export=.

- =:noeval= ::
     Is the same as =:eval no=.

*** Remarks

Sometimes, to *switch off execution* of code blocks *during export*, you can find
it easy to simply manually generate the results of a code block (e.g., through
an interactive evaluation), and set the =:eval= property of the code block to
=never-export=.

Note that, unlike [[#tangle][tangling]], evaluation requires the specific language to be
supported for both performing the evaluation and collecting the [[#results][results]].

*** See also

**** Reference

[[#cache][:cache]] \\
[[#exports][:exports]] \\
[[#session][:session]]

**** Variable

=org-confirm-babel-evaluate=

** :exports
   :PROPERTIES:
   :CUSTOM_ID: exports
   :END:

Specifies how code and/or results should be handled *during export*.

*** Options

- =:exports none= ::
     Doesn't include anything in the exported file.

- =:exports code= ::
     (default)
     (default for Org code blocks)
     Includes (only) the body of the code block into the exported file.

- =:exports results= ::
     (default for /inline/ code blocks)
     (default for LaTeX code blocks)
     (default for code blocks in graphics-only languages)
     Includes (only) the *results block* in the exported file.

- =:exports both= ::
     Includes both the code block and the [[#eval][results]] in the exported file.

*** Remarks

- When =:exports= is set to =none= or =code=, Org Babel will *not [[#eval][run]]* the code block
  *during export*, avoiding to (re-)generate the results on every export. In
  particular, use that on code blocks which cannot be [[#eval][executed]] on their own.

  This has no effect on interactive [[#eval][evaluation]], though.

  If you need the code to be evaluated, put the block in a =:noexport:= entry.

- When =:exports= is set to =results= or =both=, if evaluation is allowed during
  export, the code block will be (re-)[[#eval][evaluated]] during export. Otherwise, the
  current (unchanged) results block, when present, will be included *in the
  exported file*.

*** See also

**** Reference

[[#cache][:cache]] \\
[[#eval][:eval]] \\
[[#results][:results]]

** :file
   :PROPERTIES:
   :CUSTOM_ID: file
   :END:

Specifies to *write the results to a file*.

*** Options

- =:file <FILENAME>= ::
     Writes the *results* from the code block evaluation to =<FILENAME>= and
     inserts (for the *results block*) a *link to the file* into the Org mode
     buffer.

*** Remarks

Extension can be everything: =.png=, =.pdf=, =.txt=, =.csv=, etc.

When relative, the filename is interpreted relatively to the [[#dir][default
directory]].

- For *graphics-only languages* (e.g. /asymptote/, /ditaa/, /dot/, /gnuplot/, /mscgen/,
  /plantuml/), the "results" is the *graphics*, and a link to the image is placed
  in the Org buffer.

- For *general-purpose languages* (e.g. /emacs-lisp/, /python/, /R/, /ruby/, /sh/), the
  "results" written to file is the *normal Org Babel results* (string, number,
  table).

  When generating *graphics*, including the =:results graphics= header argument is
  *required*, in addition to =:file <FILENAME>=, in order for graphical output to
  be sent automatically to file. If =:file= is supplied, but not =:results
  graphics=, then non-graphical (=value= or =output=) results are written to file.

Links to generated images will be expanded to include the contents of the
images upon export.

If you then turn on inline images with =M-x org-toggle-inline-images=, you can
preview the generated image from within your Org buffer.

Some languages including /R/, /gnuplot/, /dot/, and /ditaa/ provide special handling
of the =:file= header argument automatically wrapping the code block body in the
boilerplate code required to save output to the specified file. This is often
useful for saving graphical output of a code block to the specified file.

/This means that the argument of the =:file= header can be omitted and the
file name can be generated within the source block./

*** Examples

**** Saving the textual output from a general-purpose language to a text file

Send the text output of =ls -l= directly to a file:

#+begin_src sh :results output :file dirlisting.txt :exports both
ls -l
#+end_src

#+results:
[[file:dirlisting.txt]]

Recall that =:results value= is the default.

**** Saving the graphical output from a general-purpose language to an image file

XXX Output is not necessary!!

#+begin_src R :results output graphics :file images/square.png :exports both
plot(1:10, (1:10)^2)
#+end_src

#+results:
[[file:images/square.png]]

**** Saving the graphical output from a graphics language to an image file

***** Dotty

#+begin_src dot :file images/dot.png :cmdline -Tpng :exports both
digraph G {
  a -> b [label="hello", style=dashed];
  a -> c [label="world"];
  b -> c;
  b [shape=Mdiamond, label="this is b"];
  c [shape=polygon, sides=5, peripheries=3];
}
#+end_src

#+results:
[[file:images/dot.png]]

Recall that =:exports results= is the default for graphics-only languages.

***** R

Choose PNG extension (and not PDF) to preview the results in the Org buffer
itself.

#+begin_src R :results graphics :file testout.png :eval yes
plot(1:10, (1:10)^2)
#+end_src

#+results:
[[file:testout.png]]

*** See also

**** Reference

[[#dir][:dir]] \\
[[#results][:results]] \\
[[#sep][:sep]] (for saving tabular results)

** :file-desc
   :PROPERTIES:
   :CUSTOM_ID: file-desc
   :END:

Specifies a description for file results.

** :hlines
   :PROPERTIES:
   :CUSTOM_ID: hlines
   :END:

Handles *horizontal lines* in input tables.

*** Options

- =:hlines no= ::
     (default)
     Strips horizontal lines from the input table.

- =:hlines yes= ::
     (default for Emacs Lisp code blocks)
     Preserves horizontal lines in the input table.

*** Remarks

*Don't confound this with the [[#colnames][:colnames]] machinery.*

*** Examples
    :PROPERTIES:
    :eval:     yes
    :END:

#+name: one-hline
| Key | Val   |
|-----+-------|
|   1 | one   |
|   2 | two   |
|   3 | three |

#+name: two-hlines
| Key | Val   |
|-----+-------|
|   1 | one   |
|   2 | two   |
|-----+-------|
|   3 | three |

#+name: echo-input
#+begin_src emacs-lisp :var data=one-hline :results scalar :hlines no
  data
#+end_src

#+results: echo-input
: ((1 "one") (2 "two") (3 "three"))

#+begin_src emacs-lisp :var data=two-hlines :results scalar :hlines no
  data
#+end_src

#+results:
: (("Key" "Val") (1 "one") (2 "two") (3 "three"))

#+begin_src emacs-lisp :var data=one-hline :results scalar :hlines yes :eval yes
  data
#+end_src

#+results:
: ((1 "one") (2 "two") (3 "three"))

#+begin_src emacs-lisp :var data=two-hlines :results scalar :hlines yes :eval yes
  data
#+end_src

#+results:
: (("Key" "Val") hline (1 "one") (2 "two") hline (3 "three"))

The =:hlines yes= header argument must be set on the call line itself.

#+call: echo-input(data=one-hline) :hlines yes

#+results:
: ((1 "one") (2 "two") (3 "three"))

#+call: echo-input(data=two-hlines) :hlines yes

#+results:
: (("Key" "Val") (1 "one") (2 "two") (3 "three"))

*** See also

**** Reference

[[#colnames][:colnames]]

** :mkdirp
   :PROPERTIES:
   :CUSTOM_ID: mkdirp
   :END:

Toggles creation of parent directories of target files during tangling.

*** Options

- =:mkdirp no= ::

- =:mkdirp yes= ::

** :no-expand
   :PROPERTIES:
   :CUSTOM_ID: no-expand
   :END:

** :noweb
   :PROPERTIES:
   :CUSTOM_ID: noweb
   :END:

Specifies when expansion of "noweb" style references should occur.

*** Options

- =:noweb no= ::
     (default)

- =:noweb yes= ::
     Expands noweb references in code blocks during both tangling and
     evaluation (interactively and during export).

- =:noweb strip-export= ::
     Expands noweb references in code blocks before the block is tangled or
     evaluated. However, they will be *stripped on export*.

- =:noweb no-export= ::
     Expands noweb references during tangling and interactive evaluation, but
     not during export.

- =:noweb tangle= ::
     Expands noweb references only during tangling, but not during interactive
     evaluation nor during export.

- =:noweb eval= ::
     Expands noweb references *only* during interactive evaluation.

*** Examples

**** Expand block

**** Execute block

Note the parens in the noweb reference:

#+name: testing
#+BEGIN_SRC sh :results raw
echo "["
ls *.org | sed 's/$/;/'
echo "]"
#+END_SRC

#+BEGIN_SRC ocaml :noweb yes
let x =
<<testing()>>
in x
#+END_SRC

*** See also

**** Reference

[[#comments][:comments]] \\
[[#noweb-ref][:noweb-ref]] \\
[[#noweb-sep][:noweb-sep]] \\
[[#padline][:padline]] \\
[[#tangle][:tangle]]

**** Concepts

Noweb references

** :noweb-ref
   :PROPERTIES:
   :CUSTOM_ID: noweb-ref
   :END:

Specifies block's noweb reference resolution target.

*** Options

*** Remarks

This allows you to *avoid repeating the reference name* in your Org document: if
you set this header argument at the file or subtree level, the code blocks will
be concatenated into the *propagated* reference name -- if *property inheritance*
is turned on for the =noweb-ref= property.

*** Examples

#+begin_src org
,*** Some subtree
    :PROPERTIES:
    :noweb-ref: accumulated
    :END:

,#+begin_src org
first
,#+end_src

,#+begin_src org
second
,#+end_src

,#+begin_src sh :results output :noweb yes
echo <<accumulated>>
,#+end_src

,#+results:
,#+begin_example
first
second
,#+end_example
#+end_src

*** See also

**** Reference

[[#noweb][:noweb]] \\
[[#noweb-sep][:noweb-sep]]

**** Other resources

The variable =org-babel-use-quick-and-dirty-noweb-expansion= controls XXX

** :noweb-sep
   :PROPERTIES:
   :CUSTOM_ID: noweb-sep
   :END:

Specifies the string to use to separate accumulated noweb references.

*** Options

By default a newline is used.

*** See also

**** Reference

[[#noweb][:noweb]] \\
[[#noweb-ref][:noweb-ref]]

** :padline
   :PROPERTIES:
   :CUSTOM_ID: padline
   :END:

Controls insertion of padding lines in tangled code files.

*** Options

- =:padline yes= ::
     (default)

- =:padline no= ::
     Gets rid of the *first blank line* preceding tangled output.

*** Remarks

The padline is not inserted at the top of the file, only between blocks.

*** See also

**** Reference

[[#noweb][:noweb]]

** :post
   :PROPERTIES:
   :CUSTOM_ID: post
   :END:

Post-processes the results of a code block.

*** Remarks

1. When a post argument is given, the results of the code block will
   temporarily be bound to the =*this*= variable. This variable may then be
   included in header argument forms such as those used in =var= header argument
   specifications allowing passing of results to other code blocks, or direct
   execution via Emacs Lisp.

2. For example, the =:post= header argument could link to an Emacs Lisp source
   code block which does automatically refresh the inline images of (only)
   certain blocks (and not others).

*** Examples

We can have a sequence of forward chained blocks with length > 2.

#+name: mult
#+begin_src emacs-lisp :var in=0
  (* 2 in)
#+end_src

#+name: add
#+begin_src emacs-lisp :var in=0
  (+ 1 in)
#+end_src

Putting the previous two together we get.

#+begin_src emacs-lisp :post mult(add(*this*))
  4
#+end_src

#+RESULTS:
: 10

** :prologue
   :PROPERTIES:
   :CUSTOM_ID: prologue
   :END:

Prepends text to code block body.

*** Options

- =:prologue ""= ::
     (default)

- =:prologue <TEXT>= ::
     Prepends the value of the =:prologue= header argument to the code block
     body before execution.

*** See also

**** Reference

[[#epilogue][:epilogue]]

** :results
   :PROPERTIES:
   :CUSTOM_ID: results
   :END:

Specifies the type of results and how they will be collected and handled.

*** Options

**** How the code block is evaluated

Specifies how the results should be *collected* from the code block's
evaluation.

- =:results value= (aka functional mode) ::
     (default)
     Specifies that the results of the block is the *value of the last
     statement* in your code, turned into an *Org mode table* if it is a
     list/vector type object.

- =:results output= (aka scripting mode) ::
     (default for Ledger code blocks)
     Specifies that the results will be *everything printed to stdout* during
     execution of the code block. The strings collected from =stdout= are not
     treated as values, but rather as *raw strings*.

If you get the message ~Source block produced no output~, try adding =:results
output=.

**** How the results are inserted into the Org mode buffer

***** Handling params

Specifies if and how the results should be *inserted in the buffer*.

- =:results replace= ::
     (default)
     Inserts results after the code block, replacing any previously inserted
     results.

- =:results silent= ::
     (default for Org and Screen code blocks)
     Sends the commands, echoes the results in the minibuffer (to see code
     block output), but *does not change the Org mode buffer* (even during
     export, *no results are inserted* into the exported document).

- =:results none= ::
     Silents the results, even for the minibuffer. By definition, such a code
     block is run for its side effects.

- =:results append= ::
     Builds new results onto existing results.

- =:results prepend= ::
     Is the same as =append=, but puts new results before the existing results.

***** Type

Specifies how the results should be *interpreted*.

- =:results verbatim= ::
     (default for =raw=, =org= and =drawer= results)
     Informs explicitly the code block that you will be returning a string, to
     *inhibit its interpretation* as a value --- the output will neither be
     converted into a table nor into a list.

     #+begin_src emacs-lisp :var data="" :results verbatim
     (concat "\\begin{mdframed}\n" data "\n")
     #+end_src

     #+results:
     #+begin_example
     "\\begin{mdframed}

     "
     #+end_example

     #+begin_src emacs-lisp :var data="string"
     (concat "\\begin{mdframed}\n" data "\n")
     #+end_src

     #+results:
     #+begin_example
     \begin{mdframed}
     string
     #+end_example

- =:results table= ::
     (default)
     Interprets the results as an Org mode table.

- =:results list= ::
      Writes an Org mode list.

     #+begin_src sh :results drawer list
     echo "vino blanco"
     echo "vino rosso"
     echo "vino tinto"
     #+end_src

     #+results:
     :RESULTS:
     - vino blanco
     - vino rosso
     - vino tinto
     :END:

- =:results file= ::
     (default for code blocks in graphics-only languages)
     *Interprets the results as a file path*, and insert it into the buffer
     using the Org mode file syntax.

- =:results graphics= ::
     (extra option for code blocks in maxima, octave and R)
     XXX

- =:results vector= ::
     Is the same as =:results table=.

- =:results scalar= ::
     Is the same as =:results verbatim=.

***** Format

Specifies what type of results the code block will return.

- =:results raw= ::
     (default for Org code blocks)
     (implies =verbatim= results, unless otherwise stated)
     Means that the input is a string (so hline processing is not performed).

     #+begin_src emacs-lisp :results raw :exports both
     "* Headline\nParagraph"
     #+end_src

- =:results html= ::
     Specifies that the *results* of the code block is *raw HTML code* (which can
     be included correctly in HTML-based export targets). Is the same as =:wrap
     HTML=.

     Inserts the results inside a =#+BEGIN_HTML= block.

     #+begin_src emacs-lisp :results html :exports both
     "output <b>HTML</b> formatted text"
     #+end_src

     #+results:
     #+BEGIN_HTML
     output <b>HTML</b> formatted text
     #+END_HTML

- =:results latex= ::
     (default for LaTeX code blocks)
     Specifies that the *results* of the code block is *raw LaTeX code* (which can
     be included correctly in LaTeX-based export targets). Is the same as
     =:wrap LaTeX=.

     Inserts the results inside a =#+BEGIN_LaTeX= block.

     #+begin_src emacs-lisp :results latex :exports both
     "output \\textbf{\\LaTeX} formatted text"
     #+end_src

     #+results:
     #+BEGIN_LaTeX
     output \textbf{\LaTeX} formatted text
     #+END_LaTeX

     #+begin_src maxima :results output latex
     tex(exp(-x)/x);
     #+end_src

     #+results:
     #+BEGIN_LaTeX
     $${{e^ {- x }}\over{x}}$$
     #+END_LaTeX

- =:results org= ::
     (implies =verbatim= results, unless otherwise stated)
     *Wraps raw Org mode results* in a =#+BEGIN_SRC org= block (dead data,
     *comma-escaped lines*). This will be *exported as Org code block* (as
     =verbatim= or =listings= to LaTeX).

     #+begin_src emacs-lisp :results org :exports both
     "* Headline\nParagraph"
     #+end_src

     #+results:
     #+BEGIN_SRC org
     ,* Headline
     Paragraph
     #+END_SRC

- =:results drawer= ::
     (replacement of =:results wrap=, since Org 7.9.2)
     (implies =verbatim= results, unless otherwise stated)
     *Wraps code block results* in a =RESULTS= drawer. This has the benefit of
     delimiting your results, and can be useful for really inserting pure *Org
     mode syntax* in the buffer (live data, *not escaped*) --- which can be
     included correctly *in all export targets*.

     #+begin_src sh :results drawer :exports both
     cat <<EOF
     | a | b |
     |---+---|
     | 1 | 2 |

     [[./plots/file1.pdf]]

     [[./plots/file2.pdf]]
   EOF
     #+end_src

     #+results:
     :RESULTS:
     | a | b |
     |---+---|
     | 1 | 2 |

     [[./plots/file1.pdf]]

     [[./plots/file2.pdf]]
     :END:

- =:results code= ::
     This will be *exported as <LANG> code block* (as =verbatim= or =listings= to
     LaTeX).

     #+begin_src emacs-lisp :results code :exports both
     "* Headline\nParagraph"
     #+end_src

     #+results:
     #+BEGIN_SRC emacs-lisp
     "* Headline\nParagraph"
     #+END_SRC

- =:results pp= ::
     Prints data.
     Puts the output in an =EXAMPLE= block? XXX

     #+begin_src emacs-lisp :results pp :exports both
     "* Headline\nParagraph"
     #+end_src

     #+results:
     : "* Headline\nParagraph"

*** Remarks

With =raw=, as there are *no obvious markers to delimit the results* in the Org
mode buffer, there is no way to know where raw results begin or end. So,
=:results raw replace= will never work as expected: *raw results cannot be removed*
(they become part of the buffer), and you'll get duplicates when re-evaluating
the code block.

The sole purpose of =raw= results is to allow inserting an headline (a real
headline, not comma protected) in the buffer, because headlines cannot be
contained in anything else than headlines.

If the generated code doesn't contain an headline, you don't need =raw= results.

A block wrapper makes it possible for the entirety of the results to be
clearly located, regardless of their contents, and replaced (with new results)
by Babel upon code block re-evaluation.

*** Examples

**** Interpreting the results as a file path

#+begin_src python :results file
from pylab import *
plot(rand(10))
savefig('images/test.png')
'images/test.png'
#+end_src

*** See also

**** Reference

[[#exports][:exports]] \\
[[#file][:file]] \\
[[#wrap][:wrap]]

** :rownames
   :PROPERTIES:
   :CUSTOM_ID: rownames
   :END:

Handles row names in tables.

*** Options

- =:rownames no= ::
     (default)

- =:rownames yes= ::
     Tells Org that your first column contains row names.

*** See also

**** Reference

[[#colnames][:colnames]] \\
[[#wrap][:wrap]]

** :sep
   :PROPERTIES:
   :CUSTOM_ID: sep
   :END:

Specifies a delimiter for reading or writing *tabular results*.

*** Options

- none ::
     Uses TAB as default separator.

- =:sep <SEPARATOR>= ::
     Sets separator to =<SEPARATOR>=.

*** Examples

**** Saving the tabular output to a CSV file

Save the output of =ls -l= as a =.csv= file.

#+begin_src sh :file dirlisting.csv :sep ,
ls -l
#+end_src

#+results:
[[file:dirlisting.csv]]

Recall that =:results value= is the default.

*** See also

**** Reference

[[#file][:file]]

** :session
   :PROPERTIES:
   :CUSTOM_ID: session
   :END:

Shares data and persists state between (evaluation of) different code blocks.

*** Options

- =:session none= ::
     (default)
     Disables session-based evaluation.

- =:session <NAME>= ::
     Performs evaluation using a persistently running inferior process to
     which the code block is submitted.

     (default for Screen code blocks: session name set to =default=)

*** Remarks

Even if you don't need to share data between blocks, you can still use
sessions in order not to wait for the interpreter to start up for each block!

It also allows for manual inspection of the results of evaluation.

When you work on different files at the same time, you may want to use:
- the same session, or
- differently named sessions (running their own process).

*** See also

**** Reference

[[#eval][:eval]]

** :shebang
   :PROPERTIES:
   :CUSTOM_ID: shebang
   :END:

Uses preamble for tangled files (and make them executable).

*** Options

- =:shebang <SHEBANG>= ::
     Specifies the shebang.

*** Remarks

The preamble line is only used for tangling, not during evaluation.

Note that whenever a file is tangled which includes a shebang line, Org Babel
will make the file executable, so there is good reason to *only add shebangs
at the source-code level*.

*** Examples

Set the shebang.

#+begin_src sh :shebang #!/usr/bin/env sh :tangle t.sh
printf "with a shebang line, I can be run as a script!\n"
#+end_src

#+results:
| with a shebang line | I can be run as a script! |

** :tangle
   :PROPERTIES:
   :CUSTOM_ID: tangle
   :END:

Toggles tangling and specify file name.

*** Options

- =:tangle no= ::
     (default)

- =:tangle yes= ::
     Tangles to a target file named after the name of the Org mode file
     (=$(basename).<MODE-EXT>=).

- =:tangle <FILENAME>= ::
     Specifies an alternate target file.

*** Remarks

Tangling works for *any* programming language (even those which have yet to be
created and have no explicit Emacs or Org mode support) because, on tangling,
the code block is simply treated as text.

Blocks to the same target file are *concatenated* during tangling, IN THE ORDER
AT WHICH THEY APPEAR IN THE ORG SOURCE FILE.

Blocks which are under a =COMMENT='ed heading (including parents) are not
tangled.

Propagating changes back from tangled code to Org mode blocks (aka
"*detangling*") is possible with the function =org-babel-detangle=.

*** See also

**** Reference

[[#noweb][:noweb]]

** :tangle-mode

Controls the permissions of tangled files.

** :var
   :PROPERTIES:
   :CUSTOM_ID: var
   :END:

*Passes arguments* to code blocks.

*** Options

- =:var <NAME>=<VALUE>= ::
     Assigns a *default* value (literal or reference to a literal, a table, a
     list or a code block) to the argument.

*** Remarks

Multiple =var= specifications behind a single =:var= are allowed. The multiple var
arguments must be comma-separated:

#+begin_src org
,#+PROPERTY: var foo=1, bar=2
,#+begin_src emacs-lisp
(+ foo bar)
,#+end_src

,#+results:
: 3
#+end_src

and

#+begin_src org
,#+begin_src emacs-lisp :var foo="hello", bar="world"
(concat foo " " bar)
,#+end_src

,#+results:
: hello world
#+end_src

*************** TODO Question about prefix char
  So, the prefix char of such lines should be =|=, =:= or =-=?
*************** END

The value passed to an argument can be:

- a *literal* value
  + string (value wrapped in double quotes)
  + number

- a *reference* to *named data*
  + literal *example block*
  + (part of) a *table* (when naming a table, =#+name:= should replace =#+tblname:=,
    which still exists for backwards compatibility)
  + (level-1) *list*

- a *reference* to the results of a *named code block*

- *Emacs Lisp code*

  Look in the manual at the description of what causes header arguments to be
  interpreted as Emacs Lisp.

  *Note --* Eric means about '(...) or (...)

  Arbitrary Emacs Lisp can be placed inside of header arguments, and the =org-sbe=
  take the name of a code block and returns its results.

To specify a *subset* of a table, give a =[row,column]= index.

- Indices are numerical and begin at 0.
- Column names, hlines and row names do count in the indexes.
- Negative numbers imply counting back from the end.
- Ranges (consecutive rows or columns) are specified using the colon notation
  =first:last=.
- If row or column is empty, then all rows or all columns are taken.

To reference a variable in an external file, use the syntax =:var
data=<FILE>:<VAR>=. Note that, in order to work, the files must be in the same
directory.

:var introduces code block dependencies.
include anything in the Org mode file that takes a @code{#+NAME:},
@code{#+BEGIN_EXAMPLE} blocks, other code blocks, and the results of other
code blocks. +When a reference is made to another code block, the referenced
block will be+evaluated whenever needed, in order to supply its value to the
referencing+block. If the referenced block is cached (see @ref{cache}), its
value will+be reused if possible, instead of being re-calculated. If the
referring code+block is cached, its hash value will depend on the value of all
the code+blocks it references.

*** Examples

**** Literal string

#+begin_src R :exports results :var name="value"
print(name)
#+end_src

#+results:
: value

**** Literal number

#+begin_src R :exports results :var name=42
print(name)
#+end_src

#+results:
: 42

**** Reference to a literal example block

#+name: example-block
#+begin_example
Les sanglots longs
des violons de l'automne
#+end_example

#+begin_src R :exports results :var text=example-block
print(text)
#+end_src

#+results:
| Les sanglots longs       |
| des violons de l'automne |

**** Reference to part of a table

#+name: data3x3
| 0 | foo1 | bar1 |
| 1 | foo2 | bar2 |
| 2 | foo3 | bar3 |

#+begin_src emacs-lisp :exports results :var data=data3x3[1:2,0:2]
data
#+end_src

#+results:
| 1 | foo2 | bar2 |
| 2 | foo3 | bar3 |

#+begin_src emacs-lisp :exports results :var data=data3x3[-2:-1,]
data
#+end_src

#+results:
| 1 | foo2 | bar2 |
| 2 | foo3 | bar3 |

#+name: data3x3-colnames
| id | var1 | var2 |
|----+------+------|
|  0 | foo1 | bar1 |
|  1 | foo2 | bar2 |
|  2 | foo3 | bar3 |

#+begin_src emacs-lisp :exports results :var data=data3x3-colnames[1,]
data
#+end_src

#+results:
: hline

**** Reference to a list

#+name: list
- foo
- bar
- baz

#+begin_src emacs-lisp :exports results :var data=list
data
#+end_src

#+results:
| foo | bar | baz |

**** Reference to a code block

Chaining calculations, possibly in different languages.

#+name: foo
#+begin_src R :exports results
x <- 1:12 ; dim(x) <- c(3,4)
x
#+end_src

#+results: foo
| 1 | 4 | 7 | 10 |
| 2 | 5 | 8 | 11 |
| 3 | 6 | 9 | 12 |

#+begin_src R :var x=foo()
rowSums(x)
#+end_src

#+RESULTS:
| 22 |
| 26 |
| 30 |

** :wrap
   :PROPERTIES:
   :CUSTOM_ID: wrap
   :END:

Delimit the results (of source block evaluation).

*** Options

- none ::
     (default)
     Tells Org Babel *not* to *wrap* the results.

- =:wrap= ::
     Specifies to wrap the results in a =#+BEGIN/END_RESULTS= block.

- =:wrap <MARKUP>= ::
     Specifies the name of the block (=#+BEGIN/END_<MARKUP>=) with which to wrap
     the results.

*XXX How to unset it (when set in a higher level)?*

*** Remarks

The =:wrap= header argument gives you control over the formatting of results
from code blocks.

*** Examples

**** Using =:wrap= with no value

The following example wraps the results in =#+BEGIN_RESULTS= ... =#+END_RESULTS=
block.

#+begin_src R :exports results :wrap
x <- 1:12 ; dim(x) <- c(3,4)
x
#+end_src

#+results:
#+BEGIN_RESULTS
| 1 | 4 | 7 | 10 |
| 2 | 5 | 8 | 11 |
| 3 | 6 | 9 | 12 |
#+END_RESULTS

**** Using =:wrap= with a string value

The following examples puts the *output in an =EXAMPLE= block*.

#+begin_src R :exports results :results raw :wrap EXAMPLE
print("Some results wrapped in an example block.")
#+end_src

#+results:
#+BEGIN_EXAMPLE
Some results wrapped in an example block.
#+END_EXAMPLE

**** Using =:wrap= to produce a source code block in a named language

The following examples puts the results into a =SRC= code block (associated to
the =c++= mode).

#+begin_src R :exports results :results raw :wrap SRC c++
print("for (int i = 0; i < random; i++) {
  number[i] = rand();
}")
#+end_src

#+results:
#+BEGIN_SRC c++
for (int i = 0; i < random; i++) {
  number[i] = rand();
}
#+END_SRC

On LaTeX export, the =SRC= block will be exported as =c++= code under =listings=
instead of being wrapped in a =\begin{verbatim}..\end{verbatim}= environment.

Alternatively, you can use the :post header argument to wrap the results in a
source block.

#+name: wrap-src-cpp
#+begin_src emacs-lisp :var text="" :results raw
(concat "#+BEGIN_SRC c++\n" text "\n#+END_SRC")
#+end_src

#+name: example
#+begin_src c++ :results replace drawer :exports results :post wrap-src-cpp(text=*this*)
for (int i = 0; i < random; i++) {
  number[i] = rand();
}
#+end_src

#+results: example
:RESULTS:
nil
:END:

*** See also

**** Reference

[[#results][:results]]

* Data types

* Subtleties

** Sh-mode

> Why is the `diff' command alone not exported while the piped `diff' via
> `cat' works?

The exit code is not zero since diff found differences, so Babel assumes the
script produced an error.  Try this instead when you don't know what the
return code of the last command will be or if you know that it isn't zero
even when no error occured:

#+BEGIN_SRC sh :exports results :results output
diff testdiff.txt.orig testdiff.txt
:
#+END_SRC

> Is this this a bug?

I don't think so, although Babel could give a more enlightening message
about why it didn't evaluate STDOUT.  It gives this on your original example:

Babel evaluation exited with code 1
Code block produced no output.

* References

- [[http://orgmode.org/org.pdf][The Org Manual]]

- [[http://orgmode.org/worg/][Worg]] site

- Mailing list [[mailto:emacs-orgmode@gnu.org][emacs-orgmode@gnu.org]]

#  LocalWords:  maxima Niessen fniessen pirilampo CSS SQL org-sbe TBLFM PID
#  LocalWords:  elisp Inline inline hline noweb
